{
    "collab_server" : "",
    "contents" : "# reco_mat <- m4$qsa\n# Ti <- 200\n# ss <- simulate_dataset(N = 20, Ti = 100, reco_mat = m4$qsa)\n\nsimulate_dataset <- function(N, Ti, reco_mat, e_greedy = TRUE){\n    \n  global_simu <- list()\n  for(i in 1:N){\n    \n    # choose next actions via sub-optimal policy\n    if(e_greedy){\n      current_reco = apply(reco_mat, 1, e_greedy, e = 0.30)      \n    }else{\n      current_reco = apply(reco_mat, 1, greedy)\n    }\n    \n    # simulate new batch of data\n    simu <- my_simulate_batch(N = Ti, reco = current_reco, prior_init = NULL)\n    \n    # add lagged variables\n    simu$daytime_1 <- simu$daytime_0\n    simu$daytime_1[-Ti] <- simu$daytime_0[-1]\n    simu$glucose_1 <- c(simu$glucose_0[-1], NA)\n    global_simu[[i]] <- simu[1:(Ti-1),]\n    \n  }\n  \n  global_simu <- do.call(rbind.data.frame, global_simu)\n  return(global_simu)\n  \n}\n\n#' @title simulate data batch\n#' @param N : nb simulation steps\n#' @param dag : DAG from which to sample\nsimulate_batch <- function(N, reco = NULL, prior_init = NULL){\n  \n  # if NULL, uniform recommendations\n  if(is.null(reco)){\n    base::sample(x = 1:length(levels_action_), replace = TRUE, size = nb_states_)\n  }\n  \n  # result data frame\n  res <- data.frame('time' = 1:N, \n                    'daytime_0' = factor(x = NA, levels = levels_daytime_), \n                    'glucose_0' = NA,\n                    'action_0' = NA)\n  \n  # init\n  ## TODO: use prior_init in this section\n  index <- base::sample(x = 1:nrow(tm_), size = 1)\n  d0 <- tm_$daytime_0[index] # factor(x = base::sample(x = levels_daytime_, size = 1), levels = levels_daytime_)\n  g0 <- tm_$glucose_0[index] # min(500, max(30, rnorm(n = 1, mean = 100, sd = 30)))\n  s0 <- get_state_2(daytime_0 = d0, glucose_0 = g0)\n  a0 <- reco[s0]\n\n  # run\n  for(i in 1:N){\n    # save values\n    res$daytime_0[i] <- d0 ; res$glucose_0[i] <- g0 ; res$action_0[i] <- a0\n    # generate daytime_1 | daytime_0\n    d1 <- dag_$sampler_1(daytime_0 = d0)\n    # generate glucose_1 | glucose_0, action_0, daytime_0\n    g1 <- dag_$sampler_3(glucose_0 = g0, daytime_1 = d1, action_0 = a0)\n    # generate action_0 | glucose_0, daytime_0\n    s1 <- get_state_2(daytime_0 = d1, glucose_0 = g1)\n    a1 <- reco[s1]\n    # change containers\n    d0 <- d1 ; g0 <- g1 ; a0 <- a1\n  }\n  #\n  res$action_0 <- factor(x = levels_action_[res$action_0], levels = levels_action_)\n  return(res)\n}\n\n### TESTS\n# res <- simulate_batch(N = 1000)\n# plot.ts(res[1:100,])\n# table(res$daytime_0)\n\n#' @title simulate next state based on current state \n#' @param daytime_0\n#' @param glucose_0\n#' @param action_0\nsimulate_one_observation_from <- function(daytime_0, glucose_0, action_0){\n  # generate daytime_1 | daytime_0\n  d1 <- dag_$sampler_1(daytime_0 = daytime_0)\n  # generate glucose_1 | glucose_0, action_0, daytime_0\n  g1 <- dag_$sampler_3(glucose_0 = glucose_0, daytime_1 = d1, action_0 = action_0)\n  return(list('daytime_0' = d1, 'glucose_0' = g1))\n}\n\n#' @title simulate batch with deciced policy, stored in reco vector\n#' @param N : nb simulation steps\n#' @param reco : same size as the number of states, guides the decision-making\nsimulate_batch_w_reco <- function(N, reco){\n  \n  # result data frame\n  res <- data.frame('time' = 1:N, \n                    'daytime_0' = factor(x = NA, levels = levels_daytime_), \n                    'glucose_0' = NA,\n                    'action_0' = factor(x = NA, levels = levels_action_))\n  \n  # init\n  d0 <- factor(x = sample(x = levels_daytime_, size = 1), levels = levels_daytime_)\n  g0 <- min(500, max(30, rnorm(n = 1, mean = 100, sd = 30)))\n  s0 <- get_state(daytime_0 = d0, glucose_0 = g0)\n  a0 <- levels_action_[reco[s0]]\n  \n  # run\n  for(i in 1:N){\n    # save values\n    res$daytime_0[i] <- d0 ; res$glucose_0[i] <- g0 ; res$action_0[i] <- a0\n    # generate daytime_1 | daytime_0\n    d1 <- dag_$sampler_1(daytime_0 = d0)\n    # generate glucose_1 | glucose_0, action_0, daytime_0\n    g1 <- dag_$sampler_3(glucose_0 = g0, daytime_1 = d1, action_0 = a0)\n    # generate state and take action based on recommendations\n    s1 <- get_state(daytime_0 = d1, glucose_0 = g1)\n    a1 <- levels_action_[reco[s1]]\n    # change containers\n    d0 <- d1 ; g0 <- g1 ; a0 <- a1\n  }\n  #\n  return(res)\n}\n### TESTS\n# res <- simulate_batch_w_reco(N = 1000, reco = sample(x = 1:length(levels_action_), replace = TRUE, size = nrow(state_discretization_grid)))\n# plot.ts(res[1:100,])",
    "created" : 1549122329570.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "84|74|90|0|\n",
    "hash" : "319502781",
    "id" : "EE25CF38",
    "lastKnownWriteTime" : 1549193630,
    "last_content_update" : 1549193630502,
    "path" : "~/Documents/kdd_2019_diabetes/kdd_diabetes/simulators.R",
    "project_path" : "simulators.R",
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}